<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrome Memory Matcher</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .memory-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .critical { background-color: #ffe6e6; border-color: #ff9999; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .memory-card {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
            background: white;
        }
        .memory-card h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #666;
        }
        .memory-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .memory-card .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background: #f8f9fa;
            font-weight: bold;
        }
        .match-good { background: #d4edda; }
        .match-close { background: #fff3cd; }
        .match-poor { background: #f8d7da; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        button.danger {
            background: #dc3545;
        }
        button.danger:hover {
            background: #c82333;
        }
        
        .accuracy-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .accuracy-bar {
            flex: 1;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            background: #e0e0e0;
        }
        .accuracy-fill {
            height: 100%;
            transition: all 0.5s ease;
        }
        .accuracy-high { background: #4caf50; }
        .accuracy-medium { background: #ff9800; }
        .accuracy-low { background: #f44336; }
        
        .method-details {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .live-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .manual-input {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .manual-input input {
            width: 100px;
            padding: 5px;
            margin: 0 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>🎯 Chrome Memory Matcher</h1>
    
    <div class="memory-section info">
        <h3>📋 Instructions</h3>
        <p><strong>Goal:</strong> Match the exact memory value Chrome shows when you hover over the tab.</p>
        <p><strong>Method:</strong> Hover over your extension tab and enter the exact memory value below, then click "Start Matching" to calibrate our estimation.</p>
    </div>

    <div class="memory-section manual-input">
        <h3>🎯 Chrome Tab Memory Input</h3>
        <label>
            <strong>Chrome reports tab using:</strong>
            <input type="number" id="chromeReportedMemory" placeholder="85" min="1" max="1000">
            <select id="memoryUnit">
                <option value="MB">MB</option>
                <option value="KB">KB</option>
                <option value="GB">GB</option>
            </select>
        </label>
        <button onclick="startMemoryMatching()">Start Matching</button>
        <button onclick="clearCalibration()" class="danger">Clear Calibration</button>
    </div>

    <div class="memory-section">
        <h3>🧮 Memory Estimation Methods</h3>
        <button onclick="testAllMethods()">Test All Methods</button>
        <button onclick="startLiveComparison()">Start Live Comparison</button>
        <button onclick="stopLiveComparison()">Stop Live Comparison</button>
        <div id="methodResults"></div>
    </div>

    <div class="memory-section">
        <h3>📊 Accuracy Analysis</h3>
        <div id="accuracyResults"></div>
    </div>

    <script>
        let liveComparisonInterval = null;
        let calibrationData = {
            chromeReported: null,
            bestMethod: null,
            calibrationFactor: 1.0
        };

        // Load calibration data from localStorage
        function loadCalibration() {
            const saved = localStorage.getItem('chromeMemoryCalibration');
            if (saved) {
                calibrationData = JSON.parse(saved);
                document.getElementById('chromeReportedMemory').value = calibrationData.chromeReported ? (calibrationData.chromeReported / (1024 * 1024)).toFixed(0) : '';
                console.log('📚 Loaded calibration data:', calibrationData);
            }
        }

        // Save calibration data
        function saveCalibration() {
            localStorage.setItem('chromeMemoryCalibration', JSON.stringify(calibrationData));
            console.log('💾 Saved calibration data:', calibrationData);
        }

        // Start memory matching process
        function startMemoryMatching() {
            const input = document.getElementById('chromeReportedMemory').value;
            const unit = document.getElementById('memoryUnit').value;
            
            if (!input) {
                alert('Please enter the memory value Chrome shows when hovering over the tab');
                return;
            }
            
            const multiplier = unit === 'MB' ? 1024 * 1024 : unit === 'KB' ? 1024 : 1024 * 1024 * 1024;
            calibrationData.chromeReported = parseFloat(input) * multiplier;
            
            console.log('🎯 Target Chrome memory:', formatBytes(calibrationData.chromeReported));
            
            testAllMethods();
        }

        // Clear calibration
        function clearCalibration() {
            calibrationData = { chromeReported: null, bestMethod: null, calibrationFactor: 1.0 };
            localStorage.removeItem('chromeMemoryCalibration');
            document.getElementById('chromeReportedMemory').value = '';
            document.getElementById('methodResults').innerHTML = '';
            document.getElementById('accuracyResults').innerHTML = '';
        }

        // Memory estimation methods
        const estimationMethods = {
            // Method 1: Performance Memory API
            performanceMemory: async () => {
                const performanceMemory = performance.memory;
                if (!performanceMemory) return null;
                
                return {
                    name: 'Performance Memory API',
                    value: performanceMemory.usedJSHeapSize || 0,
                    details: {
                        usedJSHeapSize: performanceMemory.usedJSHeapSize,
                        totalJSHeapSize: performanceMemory.totalJSHeapSize,
                        jsHeapSizeLimit: performanceMemory.jsHeapSizeLimit
                    },
                    confidence: 30 // JS heap is only part of tab memory
                };
            },

            // Method 2: Enhanced DOM-based estimation
            domBasedEstimation: async () => {
                const domNodes = document.querySelectorAll('*').length;
                const textNodes = Array.from(document.querySelectorAll('*')).reduce((count, el) => count + el.childNodes.length, 0);
                const imageElements = document.querySelectorAll('img').length;
                const linkElements = document.querySelectorAll('link').length;
                const styleElements = document.querySelectorAll('style').length;
                
                // Get actual image memory usage
                let imageMemory = 0;
                await Promise.all(Array.from(document.querySelectorAll('img')).map(async (img) => {
                    if (img.complete && img.naturalWidth > 0) {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        try {
                            ctx.drawImage(img, 0, 0);
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            imageMemory += imageData.data.length; // RGBA bytes
                        } catch (e) {
                            imageMemory += img.naturalWidth * img.naturalHeight * 4; // Estimate
                        }
                    } else {
                        imageMemory += 50000; // 50KB fallback
                    }
                }));
                
                const heapUsed = performance.memory?.usedJSHeapSize || 0;
                
                // Chrome tab components
                const chromeBase = 35 * 1024 * 1024; // 35MB base
                const rendererOverhead = 15 * 1024 * 1024; // 15MB renderer
                const domStructure = domNodes * 200 + textNodes * 50;
                const jsExecution = heapUsed * 1.4; // Heap + 40% overhead
                const styleMemory = (linkElements + styleElements) * 10000;
                const extensionOverhead = 12 * 1024 * 1024; // Extension APIs
                const reactMemory = window.React ? 18 * 1024 * 1024 : 0; // React framework
                
                const total = chromeBase + rendererOverhead + domStructure + jsExecution + 
                             imageMemory + styleMemory + extensionOverhead + reactMemory;
                
                return {
                    name: 'Enhanced DOM Estimation',
                    value: total,
                    details: {
                        chromeBase: formatBytes(chromeBase),
                        rendererOverhead: formatBytes(rendererOverhead),
                        domStructure: `${domNodes} nodes = ${formatBytes(domStructure)}`,
                        jsExecution: formatBytes(jsExecution),
                        imageMemory: formatBytes(imageMemory),
                        styleMemory: formatBytes(styleMemory),
                        extensionOverhead: formatBytes(extensionOverhead),
                        reactMemory: formatBytes(reactMemory)
                    },
                    confidence: 75 // Good comprehensive estimate
                };
            },

            // Method 3: Heap-based multiplier approach
            heapMultiplier: async () => {
                const heapUsed = performance.memory?.usedJSHeapSize || 0;
                if (heapUsed === 0) return null;
                
                // Different multipliers based on page complexity
                const domComplexity = document.querySelectorAll('*').length;
                let multiplier = 3.0; // Base multiplier
                
                if (domComplexity > 5000) multiplier = 4.5; // Complex page
                else if (domComplexity > 2000) multiplier = 3.8; // Medium complexity
                else if (domComplexity > 500) multiplier = 3.2; // Simple page
                
                // Adjust for extension context
                if (window.chrome && chrome.runtime) {
                    multiplier += 0.8; // Extension overhead
                }
                
                // Adjust for React/frameworks
                if (window.React) {
                    multiplier += 0.5;
                }
                
                const estimated = heapUsed * multiplier;
                
                return {
                    name: 'Heap Multiplier Method',
                    value: estimated,
                    details: {
                        heapUsed: formatBytes(heapUsed),
                        multiplier: multiplier.toFixed(2),
                        domComplexity: domComplexity,
                        hasExtensionAPI: !!(window.chrome && chrome.runtime),
                        hasReact: !!window.React
                    },
                    confidence: 60 // Depends on multiplier accuracy
                };
            },

            // Method 4: Resource-based calculation
            resourceBased: async () => {
                let totalSize = 0;
                const resources = [];
                
                // Get all resources from performance API
                if (performance.getEntriesByType) {
                    const resourceEntries = performance.getEntriesByType('resource');
                    for (const entry of resourceEntries) {
                        if (entry.transferSize) {
                            totalSize += entry.transferSize;
                            resources.push({
                                name: entry.name.split('/').pop(),
                                size: entry.transferSize,
                                type: entry.initiatorType
                            });
                        }
                    }
                }
                
                // Add estimated runtime overhead
                const runtimeOverhead = totalSize * 2.5; // Resources + parsing + execution
                const chromeTabOverhead = 40 * 1024 * 1024; // 40MB Chrome tab base
                const extensionOverhead = 15 * 1024 * 1024; // 15MB extension overhead
                
                const estimated = totalSize + runtimeOverhead + chromeTabOverhead + extensionOverhead;
                
                return {
                    name: 'Resource-Based Calculation',
                    value: estimated,
                    details: {
                        resourcesSize: formatBytes(totalSize),
                        resourceCount: resources.length,
                        runtimeOverhead: formatBytes(runtimeOverhead),
                        chromeTabOverhead: formatBytes(chromeTabOverhead),
                        extensionOverhead: formatBytes(extensionOverhead),
                        topResources: resources.sort((a, b) => b.size - a.size).slice(0, 5)
                    },
                    confidence: 50 // Variable based on resource completeness
                };
            },

            // Method 5: Calibrated estimation (uses previous calibration)
            calibratedEstimation: async () => {
                if (!calibrationData.chromeReported || !calibrationData.bestMethod) {
                    return null;
                }
                
                // Run the best method and apply calibration factor
                let baseEstimate = 0;
                try {
                    const baseMethod = await estimationMethods[calibrationData.bestMethod]();
                    baseEstimate = baseMethod ? baseMethod.value : 0;
                } catch (e) {
                    baseEstimate = performance.memory?.usedJSHeapSize * 3.5 || 0;
                }
                
                const calibrated = baseEstimate * calibrationData.calibrationFactor;
                
                return {
                    name: 'Calibrated Estimation',
                    value: calibrated,
                    details: {
                        baseMethod: calibrationData.bestMethod,
                        baseEstimate: formatBytes(baseEstimate),
                        calibrationFactor: calibrationData.calibrationFactor.toFixed(3),
                        previousTarget: formatBytes(calibrationData.chromeReported)
                    },
                    confidence: 90 // High confidence if calibrated
                };
            }
        };

        // Test all estimation methods
        async function testAllMethods() {
            const resultsDiv = document.getElementById('methodResults');
            resultsDiv.innerHTML = '<p>🔄 Testing all memory estimation methods...</p>';
            
            const results = [];
            
            for (const [key, method] of Object.entries(estimationMethods)) {
                try {
                    console.log(`Testing method: ${key}`);
                    const result = await method();
                    if (result) {
                        results.push({ key, ...result });
                    }
                } catch (error) {
                    console.error(`Method ${key} failed:`, error);
                }
            }
            
            // Calculate accuracy if we have a target
            if (calibrationData.chromeReported) {
                results.forEach(result => {
                    const accuracy = Math.max(0, 100 - Math.abs(result.value - calibrationData.chromeReported) / calibrationData.chromeReported * 100);
                    result.accuracy = accuracy;
                    result.diff = result.value - calibrationData.chromeReported;
                });
                
                // Find best method
                const bestResult = results.reduce((best, current) => 
                    current.accuracy > best.accuracy ? current : best
                );
                
                if (bestResult && bestResult.accuracy > 50) {
                    calibrationData.bestMethod = bestResult.key;
                    calibrationData.calibrationFactor = calibrationData.chromeReported / bestResult.value;
                    saveCalibration();
                }
            }
            
            displayResults(results);
        }

        // Display test results
        function displayResults(results) {
            const resultsDiv = document.getElementById('methodResults');
            
            let html = '<table class="comparison-table">';
            html += '<thead><tr><th>Method</th><th>Estimated Memory</th><th>Confidence</th>';
            
            if (calibrationData.chromeReported) {
                html += '<th>Accuracy</th><th>Difference</th>';
            }
            
            html += '<th>Details</th></tr></thead><tbody>';
            
            results.forEach(result => {
                let rowClass = '';
                if (calibrationData.chromeReported && result.accuracy !== undefined) {
                    if (result.accuracy >= 85) rowClass = 'match-good';
                    else if (result.accuracy >= 70) rowClass = 'match-close';
                    else rowClass = 'match-poor';
                }
                
                html += `<tr class="${rowClass}">`;
                html += `<td><strong>${result.name}</strong></td>`;
                html += `<td>${formatBytes(result.value)}</td>`;
                html += `<td>${result.confidence}%</td>`;
                
                if (calibrationData.chromeReported && result.accuracy !== undefined) {
                    html += `<td>${result.accuracy.toFixed(1)}%</td>`;
                    html += `<td>${result.diff > 0 ? '+' : ''}${formatBytes(result.diff)}</td>`;
                }
                
                html += `<td><details><summary>Show Details</summary><pre>${JSON.stringify(result.details, null, 2)}</pre></details></td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (calibrationData.chromeReported && results.length > 0) {
                const bestResult = results.reduce((best, current) => 
                    (current.accuracy || 0) > (best.accuracy || 0) ? current : best
                );
                
                html += `<div class="memory-section success">`;
                html += `<h4>🎯 Best Match: ${bestResult.name}</h4>`;
                html += `<p>Accuracy: ${(bestResult.accuracy || 0).toFixed(1)}% (${formatBytes(bestResult.value)} vs target ${formatBytes(calibrationData.chromeReported)})</p>`;
                html += `</div>`;
            }
            
            resultsDiv.innerHTML = html;
            
            updateAccuracyDisplay(results);
        }

        // Update accuracy display
        function updateAccuracyDisplay(results) {
            const accuracyDiv = document.getElementById('accuracyResults');
            
            if (!calibrationData.chromeReported || results.length === 0) {
                accuracyDiv.innerHTML = '<p>Set target Chrome memory value to see accuracy analysis.</p>';
                return;
            }
            
            const bestResult = results.reduce((best, current) => 
                (current.accuracy || 0) > (best.accuracy || 0) ? current : best
            );
            
            const accuracy = bestResult.accuracy || 0;
            let accuracyClass = 'accuracy-low';
            let accuracyText = 'Poor Match';
            
            if (accuracy >= 85) {
                accuracyClass = 'accuracy-high';
                accuracyText = 'Excellent Match';
            } else if (accuracy >= 70) {
                accuracyClass = 'accuracy-medium';
                accuracyText = 'Good Match';
            }
            
            accuracyDiv.innerHTML = `
                <div class="accuracy-meter">
                    <span>Match Quality:</span>
                    <div class="accuracy-bar">
                        <div class="accuracy-fill ${accuracyClass}" style="width: ${accuracy}%"></div>
                    </div>
                    <span>${accuracyText} (${accuracy.toFixed(1)}%)</span>
                </div>
                <div class="memory-grid">
                    <div class="memory-card">
                        <h4>Chrome Target</h4>
                        <div class="value">${formatBytes(calibrationData.chromeReported)}</div>
                        <div class="subtitle">User reported</div>
                    </div>
                    <div class="memory-card">
                        <h4>Best Estimate</h4>
                        <div class="value">${formatBytes(bestResult.value)}</div>
                        <div class="subtitle">${bestResult.name}</div>
                    </div>
                    <div class="memory-card">
                        <h4>Difference</h4>
                        <div class="value">${bestResult.diff > 0 ? '+' : ''}${formatBytes(bestResult.diff)}</div>
                        <div class="subtitle">${((bestResult.diff / calibrationData.chromeReported) * 100).toFixed(1)}% off</div>
                    </div>
                </div>
            `;
        }

        // Start live comparison
        function startLiveComparison() {
            if (liveComparisonInterval) return;
            
            liveComparisonInterval = setInterval(async () => {
                if (calibrationData.chromeReported && calibrationData.bestMethod) {
                    try {
                        const result = await estimationMethods[calibrationData.bestMethod]();
                        if (result) {
                            const calibrated = result.value * calibrationData.calibrationFactor;
                            const accuracy = Math.max(0, 100 - Math.abs(calibrated - calibrationData.chromeReported) / calibrationData.chromeReported * 100);
                            
                            console.log(`🔄 Live estimate: ${formatBytes(calibrated)} (${accuracy.toFixed(1)}% accuracy)`);
                            
                            // Update extension dashboard if possible
                            if (typeof chrome !== 'undefined' && chrome.runtime) {
                                chrome.runtime.sendMessage({
                                    action: 'updateMemoryEstimate',
                                    data: {
                                        estimated: calibrated,
                                        accuracy: accuracy
                                    }
                                });
                            }
                        }
                    } catch (error) {
                        console.error('Live comparison error:', error);
                    }
                }
            }, 2000); // Every 2 seconds
            
            console.log('▶️ Started live memory comparison');
        }

        // Stop live comparison
        function stopLiveComparison() {
            if (liveComparisonInterval) {
                clearInterval(liveComparisonInterval);
                liveComparisonInterval = null;
                console.log('⏹️ Stopped live memory comparison');
            }
        }

        // Utility function
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎯 Chrome Memory Matcher Loaded');
            loadCalibration();
            
            if (typeof chrome === 'undefined' || !chrome.runtime) {
                document.body.insertAdjacentHTML('afterbegin', `
                    <div class="memory-section warning">
                        <h3>⚠️ Extension Context Required</h3>
                        <p>This tool needs to be run in your Chrome extension context for best results.</p>
                    </div>
                `);
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            stopLiveComparison();
        });
    </script>
</body>
</html>
