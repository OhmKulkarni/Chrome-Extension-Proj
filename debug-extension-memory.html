<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extension Memory Monitor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .monitor-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .critical { background-color: #ffe6e6; border-color: #ff9999; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .metric-card {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
        }
        .metric-card h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #666;
        }
        .metric-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .metric-card .subtitle {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        .progress-safe { background: #4caf50; }
        .progress-warning { background: #ff9800; }
        .progress-critical { background: #f44336; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
        }
        
        .memory-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .component-card {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        
        .alert-box {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: flex-start;
        }
        .alert-icon {
            font-size: 24px;
            margin-right: 12px;
        }
    </style>
</head>
<body>
    <h1>üß† Extension Memory Monitor</h1>
    
    <div class="monitor-section info">
        <h3>üìã Purpose</h3>
        <p><strong>Chrome Extension Memory Limit:</strong> 120MB total (includes runtime memory + IndexedDB + assets)</p>
        <p><strong>Your Report:</strong> Extension showing 85MB usage and growing - this tool monitors all components.</p>
        <p>Use the buttons below to analyze your extension's complete memory footprint.</p>
    </div>

    <div class="monitor-section">
        <h3>üéØ Real-Time Memory Monitoring</h3>
        <button onclick="startRealTimeMonitoring()" id="monitorBtn">Start Monitoring</button>
        <button onclick="stopRealTimeMonitoring()" id="stopBtn" disabled>Stop Monitoring</button>
        <button onclick="runMemorySnapshot()">Take Memory Snapshot</button>
        <div id="monitoringResult"></div>
    </div>

    <div class="monitor-section">
        <h3>‚ö° Memory Pressure Test</h3>
        <button onclick="runMemoryPressureTest()">Simulate Memory Load</button>
        <button onclick="triggerGarbageCollection()">Force Garbage Collection</button>
        <div id="pressureTestResult"></div>
    </div>

    <script>
        let monitoringInterval = null;
        let memoryHistory = [];

        // Start real-time memory monitoring
        function startRealTimeMonitoring() {
            if (monitoringInterval) return;
            
            document.getElementById('monitorBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            const resultDiv = document.getElementById('monitoringResult');
            resultDiv.innerHTML = '<p>üîÑ Starting real-time memory monitoring...</p>';
            
            monitoringInterval = setInterval(async () => {
                try {
                    const snapshot = await takeMemorySnapshot();
                    memoryHistory.push(snapshot);
                    
                    // Keep only last 20 measurements
                    if (memoryHistory.length > 20) {
                        memoryHistory.shift();
                    }
                    
                    displayRealTimeData(snapshot);
                } catch (error) {
                    console.error('Memory monitoring error:', error);
                }
            }, 2000); // Every 2 seconds
        }

        // Stop real-time monitoring
        function stopRealTimeMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }
            
            document.getElementById('monitorBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            const resultDiv = document.getElementById('monitoringResult');
            resultDiv.innerHTML += '<p>‚èπÔ∏è Monitoring stopped.</p>';
        }

        // Take a comprehensive memory snapshot
        async function takeMemorySnapshot() {
            const EXTENSION_LIMIT = 120 * 1024 * 1024; // 120MB
            
            try {
                // Get performance memory (current tab/dashboard)
                const performanceMemory = performance.memory || {};
                const dashboardHeap = performanceMemory.usedJSHeapSize || 0;
                const dashboardLimit = performanceMemory.jsHeapSizeLimit || 0;
                
                // Get background script memory
                let backgroundMemory = 0;
                try {
                    const bgResponse = await chrome.runtime.sendMessage({ action: 'getMemoryInfo' });
                    if (bgResponse && bgResponse.success) {
                        backgroundMemory = bgResponse.data.memory || 0;
                    }
                } catch (error) {
                    console.warn('Could not get background memory:', error);
                }
                
                // Get IndexedDB usage
                let indexedDBSize = 0;
                try {
                    const tableResponse = await chrome.runtime.sendMessage({ action: 'getTableCounts' });
                    if (tableResponse && tableResponse.success) {
                        const counts = Object.values(tableResponse.data || {});
                        const totalRecords = counts.reduce((sum, count) => sum + (Number(count) || 0), 0);
                        indexedDBSize = totalRecords * 1024; // Estimate 1KB per record
                    }
                } catch (error) {
                    console.warn('Could not get IndexedDB size:', error);
                }
                
                // Get browser storage quota
                let browserQuota = null;
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    try {
                        browserQuota = await navigator.storage.estimate();
                    } catch (error) {
                        console.warn('Could not get storage quota:', error);
                    }
                }
                
                // Calculate totals
                const bundleSize = 1024 * 1024; // ~1MB static bundle
                const totalExtensionUsage = dashboardHeap + backgroundMemory + indexedDBSize + bundleSize;
                const usagePercent = (totalExtensionUsage / EXTENSION_LIMIT) * 100;
                
                // Determine memory pressure
                let memoryPressure = 'low';
                if (usagePercent > 90) memoryPressure = 'critical';
                else if (usagePercent > 75) memoryPressure = 'high';
                else if (usagePercent > 50) memoryPressure = 'medium';
                
                return {
                    timestamp: Date.now(),
                    dashboardHeap,
                    dashboardLimit,
                    backgroundMemory,
                    indexedDBSize,
                    bundleSize,
                    totalExtensionUsage,
                    usagePercent,
                    memoryPressure,
                    extensionLimit: EXTENSION_LIMIT,
                    available: EXTENSION_LIMIT - totalExtensionUsage,
                    browserQuota,
                    breakdown: {
                        dashboard: dashboardHeap,
                        background: backgroundMemory,
                        indexedDB: indexedDBSize,
                        bundle: bundleSize
                    }
                };
                
            } catch (error) {
                console.error('Failed to take memory snapshot:', error);
                throw error;
            }
        }

        // Display real-time memory data
        function displayRealTimeData(snapshot) {
            const resultDiv = document.getElementById('monitoringResult');
            
            const pressureClass = snapshot.memoryPressure === 'critical' ? 'critical' 
                                : snapshot.memoryPressure === 'high' ? 'warning' 
                                : snapshot.memoryPressure === 'medium' ? 'info' 
                                : 'success';
            
            resultDiv.innerHTML = `
                <div class="${pressureClass}">
                    <h4>üß† Live Memory Status - ${new Date(snapshot.timestamp).toLocaleTimeString()}</h4>
                    
                    <div class="metrics-grid">
                        <div class="metric-card" style="background: #e3f2fd;">
                            <h4>Total Extension Usage</h4>
                            <div class="value">${formatBytes(snapshot.totalExtensionUsage)}</div>
                            <div class="subtitle">${snapshot.usagePercent.toFixed(1)}% of 120MB</div>
                        </div>
                        <div class="metric-card" style="background: #f3e5f5;">
                            <h4>Chrome Tab Memory</h4>
                            <div class="value">${formatBytes(snapshot.dashboardHeap)}</div>
                            <div class="subtitle">Should match hover</div>
                        </div>
                        <div class="metric-card" style="background: #e8f5e8;">
                            <h4>Background Memory</h4>
                            <div class="value">${formatBytes(snapshot.backgroundMemory)}</div>
                            <div class="subtitle">Service Worker</div>
                        </div>
                        <div class="metric-card" style="background: #fff3e0;">
                            <h4>IndexedDB Size</h4>
                            <div class="value">${formatBytes(snapshot.indexedDBSize)}</div>
                            <div class="subtitle">Stored Data</div>
                        </div>
                    </div>

                    <!-- Memory Pressure Indicator -->
                    <div class="progress-bar">
                        <div class="progress-fill progress-${snapshot.memoryPressure === 'critical' ? 'critical' : snapshot.memoryPressure === 'high' || snapshot.memoryPressure === 'medium' ? 'warning' : 'safe'}" 
                             style="width: ${Math.min(snapshot.usagePercent, 100)}%">
                            ${snapshot.usagePercent.toFixed(1)}% Used
                        </div>
                    </div>

                    <div class="memory-breakdown">
                        <div class="component-card">
                            <h5>üìä Memory Components</h5>
                            <ul style="list-style: none; padding: 0;">
                                <li>üöÄ Dashboard: ${formatBytes(snapshot.breakdown.dashboard)} (${((snapshot.breakdown.dashboard / snapshot.totalExtensionUsage) * 100).toFixed(1)}%)</li>
                                <li>‚öôÔ∏è Background: ${formatBytes(snapshot.breakdown.background)} (${((snapshot.breakdown.background / snapshot.totalExtensionUsage) * 100).toFixed(1)}%)</li>
                                <li>üíæ IndexedDB: ${formatBytes(snapshot.breakdown.indexedDB)} (${((snapshot.breakdown.indexedDB / snapshot.totalExtensionUsage) * 100).toFixed(1)}%)</li>
                                <li>üì¶ Bundle: ${formatBytes(snapshot.breakdown.bundle)} (${((snapshot.breakdown.bundle / snapshot.totalExtensionUsage) * 100).toFixed(1)}%)</li>
                            </ul>
                        </div>
                        
                        <div class="component-card">
                            <h5>üéØ Available Space</h5>
                            <div style="font-size: 18px; font-weight: bold; color: ${snapshot.available > 20 * 1024 * 1024 ? 'green' : snapshot.available > 10 * 1024 * 1024 ? 'orange' : 'red'};">
                                ${formatBytes(snapshot.available)}
                            </div>
                            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                remaining of 120MB limit
                            </div>
                        </div>
                    </div>

                    ${snapshot.memoryPressure === 'critical' ? `
                        <div class="alert-box critical">
                            <div class="alert-icon">üö®</div>
                            <div>
                                <strong>CRITICAL MEMORY PRESSURE!</strong><br>
                                Extension using ${snapshot.usagePercent.toFixed(1)}% of 120MB limit. 
                                Consider immediate action: clear data or reload extension.
                            </div>
                        </div>
                    ` : snapshot.memoryPressure === 'high' ? `
                        <div class="alert-box warning">
                            <div class="alert-icon">‚ö†Ô∏è</div>
                            <div>
                                <strong>High Memory Usage</strong><br>
                                Extension using ${snapshot.usagePercent.toFixed(1)}% of 120MB limit. Monitor closely.
                            </div>
                        </div>
                    ` : ''}

                    ${memoryHistory.length > 1 ? `
                        <h5>üìà Memory Trend (Last ${memoryHistory.length} measurements)</h5>
                        <div style="font-size: 12px;">
                            ${memoryHistory.slice(-5).map((m, i) => 
                                `${new Date(m.timestamp).toLocaleTimeString()}: ${formatBytes(m.totalExtensionUsage)} (${m.usagePercent.toFixed(1)}%)`
                            ).join('<br>')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Run single memory snapshot
        async function runMemorySnapshot() {
            const resultDiv = document.getElementById('monitoringResult');
            resultDiv.innerHTML = '<p>üì∏ Taking memory snapshot...</p>';
            
            try {
                const snapshot = await takeMemorySnapshot();
                displayRealTimeData(snapshot);
            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="error">
                        <h4>‚ùå Memory Snapshot Failed</h4>
                        <p>Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Simulate memory pressure
        async function runMemoryPressureTest() {
            const resultDiv = document.getElementById('pressureTestResult');
            resultDiv.innerHTML = '<p>‚ö° Running memory pressure simulation...</p>';
            
            try {
                const initialSnapshot = await takeMemorySnapshot();
                
                // Create memory pressure by allocating large arrays
                const memoryHogs = [];
                for (let i = 0; i < 10; i++) {
                    memoryHogs.push(new Array(100000).fill(`Memory test data ${i} - ${Date.now()}`));
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const pressureSnapshot = await takeMemorySnapshot();
                
                // Clean up
                memoryHogs.length = 0;
                
                const finalSnapshot = await takeMemorySnapshot();
                
                resultDiv.innerHTML = `
                    <div class="info">
                        <h4>‚ö° Memory Pressure Test Results</h4>
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <h4>Initial Memory</h4>
                                <div class="value">${formatBytes(initialSnapshot.totalExtensionUsage)}</div>
                                <div class="subtitle">${initialSnapshot.usagePercent.toFixed(1)}%</div>
                            </div>
                            <div class="metric-card">
                                <h4>Under Pressure</h4>
                                <div class="value">${formatBytes(pressureSnapshot.totalExtensionUsage)}</div>
                                <div class="subtitle">${pressureSnapshot.usagePercent.toFixed(1)}%</div>
                            </div>
                            <div class="metric-card">
                                <h4>After Cleanup</h4>
                                <div class="value">${formatBytes(finalSnapshot.totalExtensionUsage)}</div>
                                <div class="subtitle">${finalSnapshot.usagePercent.toFixed(1)}%</div>
                            </div>
                        </div>
                        <p><strong>Memory Delta:</strong> ${formatBytes(pressureSnapshot.totalExtensionUsage - initialSnapshot.totalExtensionUsage)} increase during test</p>
                        <p><strong>Cleanup Efficiency:</strong> ${formatBytes(pressureSnapshot.totalExtensionUsage - finalSnapshot.totalExtensionUsage)} freed</p>
                    </div>
                `;
                
            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="error">
                        <h4>‚ùå Memory Pressure Test Failed</h4>
                        <p>Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Force garbage collection (if available)
        function triggerGarbageCollection() {
            const resultDiv = document.getElementById('pressureTestResult');
            
            if (window.gc) {
                resultDiv.innerHTML = '<p>üóëÔ∏è Triggering garbage collection...</p>';
                window.gc();
                setTimeout(async () => {
                    const snapshot = await takeMemorySnapshot();
                    resultDiv.innerHTML = `
                        <div class="success">
                            <h4>üóëÔ∏è Garbage Collection Triggered</h4>
                            <p>Current memory usage: ${formatBytes(snapshot.totalExtensionUsage)} (${snapshot.usagePercent.toFixed(1)}%)</p>
                        </div>
                    `;
                }, 1000);
            } else {
                resultDiv.innerHTML = `
                    <div class="warning">
                        <h4>‚ö†Ô∏è Garbage Collection Not Available</h4>
                        <p>To enable manual GC, start Chrome with --js-flags="--expose-gc"</p>
                        <p>Current memory usage will be displayed from next snapshot.</p>
                    </div>
                `;
            }
        }

        // Utility function
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üß† Extension Memory Monitor Loaded');
            
            if (typeof chrome === 'undefined' || !chrome.runtime) {
                document.body.insertAdjacentHTML('beforeend', `
                    <div class="monitor-section error">
                        <h3>‚ö†Ô∏è Extension Context Required</h3>
                        <p>This memory monitor needs to be run in the context of your Chrome extension.</p>
                        <p>Open this from your extension's dashboard or popup.</p>
                    </div>
                `);
            } else {
                // Take initial snapshot
                runMemorySnapshot();
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
        });
    </script>
</body>
</html>
